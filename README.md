# 1) Содержание

1. Общая структура проекта
2. Основные классы и структуры
3. Задание 1 — анализ прочитанных книг (постановка, ход решения, ключевые методы)
4. Задание 2 — многоборье (постановка, ход решения, ключевые методы)
5. Тестирование и результаты + заметки о производительности и предложениях по улучшению

# 2) Общая структура проекта (Основные классы и структуры)

Проект состоит из следующих файлов (и соответствующих модулей):

* `main.cpp`

  * Запускает два сценария: анализ прочитанных книг (`BookAnalyzer`, читает `input.txt`) и задача многоборья (`RunCompetition`, читает `input2.txt`). Также демонстрация работы `UnorderedSet<int>`.

* `unordered_set.h` / `unordered_set.cpp`

  * Класс шаблон `UnorderedSet<T>`: динамический массив `T *data_`, методы `Add`, `Remove`, `Contains`, `Union`, `Except`, `Intersect`, `ToVector`, `Clear`, и пр. В реализации есть явная инстанциация для `int` и `std::string`.

* `dictionary.h` / `dictionary.cpp`

  * Шаблон `Dictionary<K,V>`: простой словарь на динамическом массиве пар `std::pair<K,V>`. Методы: `Add` (обновление при существующем ключе), `Remove`, `Contains`, `Get`, `ToVector`. В `.cpp` — явные инстанциации для `std::string->long long` и `std::string->int`.

* `utils.h` / `utils.cpp`

  * `Trim` и `Split` (по символу) — вспомогательные функции для работы со строками.

* Логика прикладных задач:

  * `BookAnalyzer` (определён внутри `main.cpp`) — использует `UnorderedSet<std::string>` для хранения всех книг и книг каждого читателя и выполняет операции множеств.
  * `RunCompetition` (в `main.cpp`) — читает `N`, `M`, N строк с фамилия/имя/ M баллов, суммирует баллы, сортирует, присваивает плотные места.

Ключевые структуры:

* `Athlete` (в `main.cpp`): `{ surname, name, sum, input_index }` — для сортировки и вывода результатов.

# 3) Задание 1 — анализ прочитанных книг

Постановка задачи
Имеется перечень названий книг и список читателей (у каждого — набор прочитанных книг). Нужно определить:

* Какие книги прочли все n читателей.
* Какие — некоторые (но не все).
* Какие — никто не прочитал.

Ход решения (основные методы и подход)

1. Представление множеств: `UnorderedSet<std::string>` (множества уникальных названий). Класс реализует операции над множествами:

   * `Add(value)` — добавить элемент (игнорирует дубликаты).
   * `Remove(value)` — удалить элемент.
   * `Contains(value)` — проверить наличие.
   * `Union(const UnorderedSet&)` — возвращает объединение.
   * `Except(const UnorderedSet&)` — возвращает разность (элементы первого, которых нет во втором).
   * `Intersect(const UnorderedSet&)` — пересечение.
   * `ToVector()` — конвертация в `std::vector<T>` для вывода.
2. Чтение данных (метод `BookAnalyzer::ReadData`):

   * Файл читается построчно.
   * До пустой строки — список всех книг (каталог).
   * После пустой строки — каждая строка — перечень книг, прочитанных одним читателем (разделитель `;` в `Split`).
   * Для каждого читателя создаётся `UnorderedSet` его книг; одновременно все названия добавляются в `all_books_`.
3. Анализ (`BookAnalyzer::Analyze`):

   * `books_read_by_all_` = пересечение всех множеств читателей (итеративно: start = первый читатель, затем intersect со вторым и т.д.).
   * `books_read_by_someone_` = объединение всех множеств читателей.
   * `books_read_by_some_` = `books_read_by_someone_.Except(books_read_by_all_)` — прочитанные некоторыми, но не всеми.
   * `books_read_by_none_` = `all_books_.Except(books_read_by_someone_)` — из каталога те, что никто не читал.
4. Вывод/сохранение:

   * `PrintResults()` — печать в консоль.
   * `SaveResults()` — запись в файл.

Комментарий по корректности:

* Подход корректен с точки зрения теории множеств.
* Надёжность зависит от корректности парсинга входного файла (формат: отдельные книги, затем пустая строка, затем строки с `;`-разделителями). `Split` отбрасывает пустые токены.
* Замечание: `UnorderedSet` использует линейный поиск (`Find`) для `Contains` — операции множеств работают за O(n*m) в худшем случае, что для небольших n,m допустимо.

# 4) Задание 2 — многоборье

Постановка задачи
Дано N спортсменов (N < 1000) и M видов спорта. Для каждого спортсмена дана строка: `<Фамилия> <Имя> <M чисел>`. Нужно вывести таблицу спортсменов, отсортированных по убыванию суммы баллов, и для каждого: фамилия, имя, сумма и место (плотная нумерация мест — 1,1,2...).

Ход решения (основные методы)

1. Чтение:

   * Файл (`input2.txt`) читается через `std::ifstream`.
   * Сначала читаются `N` и `M`. Проверки диапазона (N >= 0 и < 1000; M >= 0).
   * Для каждой из N строк читаются `surname`, `name`, затем M целых чисел — суммируются в `sum`.
2. Хранение:

   * Каждая запись хранится как `Athlete { surname, name, sum, input_index }`. `input_index` используется, чтобы обеспечить стабильную сортировку, если надо.
3. Сортировка:

   * Используется `std::stable_sort` с компаратором `a.sum > b.sum` — сортировка по убыванию суммы, стабильная по исходному порядку при равных суммах.
4. Присвоение мест:

   * Реализована «плотная» схема мест: сканируем отсортированный массив, увеличиваем `dense_rank` при изменении суммы (prev_sum), иначе сохраняем предыдущий rank для равных сумм. Пример: суммы 221,221,218 => ранги 1,1,2.
5. Вывод/сохранение:

   * Печать в консоль и запись в `outfile`.

Комментарий по корректности:

* Поведение соответствует требованию (пример входа/выхода в условии совпадает с логикой реализации).
* Валидация входа выполнена (проверки чтения фамилии/имени, баллов).
* Для N ≤ 1000 и разумных M алгоритм (O(N * M + N log N)) работает быстро.

# 5) Тестирование и результаты по 2 задачам и производительность

A. Рекоменованные тесты (и ожидаемые результаты)

1. **Юнит-тесты для `UnorderedSet`**
   Вход и действия:

   * пустой `UnorderedSet<int>`: `Size() == 0`, `IsEmpty() == true`.
   * `Add(1); Add(2); Add(2);` → `Size() == 2`, `Contains(1) == true`, `Contains(3) == false`.
   * `Union`, `Intersect`, `Except` проверяются на небольших наборах.
     Ожидаемый: корректные множества, дубликаты игнорируются.

2. **BookAnalyzer** — тестовый файл `input.txt`:

   ```
   Book A
   Book B
   Book C

   Book A;Book B
   Book B;Book C
   Book B
   ```

   Ожидаемый результат:

   * all_books: {A,B,C}
   * by_all: {B} (если B есть во всех списках)
   * by_some: {A,C} (в зависимости от объединения и различий)
   * by_none: {} или конкретно те, что не встречались у читателей

3. **RunCompetition** — тест `input2.txt` из примера:

   ```
   3
   4
   Иванов Сергей 100 30 78 13
   Петров Антон 90 16 98 14
   Сидоров Юрий 100 70 30 21
   ```

   Ожидаемый вывод:

   ```
   Иванов Сергей 221 1
   Сидоров Юрий 221 1
   Петров Антон 218 2
   ```

   (и аналогичная запись в `output2.txt`)

B. Фактические результаты (на основе кода в `main.cpp`)

* Код в `main.cpp` выводит демонстрацию `UnorderedSet` и вызывает оба сценария. Для приведённого `input2.txt` будет получен ожидаемый порядок и ранги (логика сортировки и присвоения rank корректна).
* Для `BookAnalyzer` корректность зависит от формата входного файла; ваш `ReadData` ожидает пустую строку-разделитель между каталогом и списками читателей — при несоблюдении формата результаты будут другое.

C. Производительность и сложность

* `UnorderedSet`:

  * `Contains`, `Find` — O(n) линейно по текущему размеру.
  * `Add` — вызывает `Contains` → O(n) + возможная рекоcтация (`EnsureCapacity`) → амортизированно O(1) на копирование, но с элементом линейного поиска получается O(n) на добавление.
  * `Union`, `Intersect`, `Except` — в общем O(n * m) (двойной проход/вложенные проверки через `Contains`).
  * Память: O(n) для массива; рост — удвоение ёмкости.
* `Dictionary`:

  * `FindIndex` — линейный поиск → операции `Add`, `Remove`, `Contains`, `Get` — все O(n) в худшем случае.
  * То есть словарь реализован как простой массив пар, не как хеш-таблица — это нормально для учебной реализации, но неэффективно при больших размерах.
* `RunCompetition`:

  * Чтение и суммирование баллов — O(N * M).
  * Сортировка — O(N log N).
  * Итого: O(N*M + N log N). При N ≤ 1000 и разумном M программа очень быстрая на современных машинах.

Practical note: для N = 1000 и M = 1000, чтение и суммирование — 1e6 операций суммирования, сортировка 1000 log 1000 ≈ 10000 сравнений. На компиляторе релиз это выполняется мгновенно (< 0.1 с), так что производительность адекватна требованиям задания.
